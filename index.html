<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Dinossaur Cladogram</title>
	<style type="text/css">
		body {
			margin: 0px;
			overflow: hidden;
			background: #1e1e2f;
		}
	</style>
</head>
<body oncontextmenu="return false;">
	<canvas id='screen'></canvas>
	<script type="text/javascript">
		const canvas = document.getElementById('screen')
		const ctx = canvas.getContext('2d')
		const TAU = Math.PI*2

		canvas.width = window.innerWidth
		canvas.height = window.innerHeight

		ctx.font = "32px Arial"
		ctx.textBaseline = 'middle'

		let cladogram
		let path_helper
		let root_node

		fetch('data.json')
		.then(res => res.json())
		.then(data => {
			root_node = cladogram = data
			path_helper = {
				children: [cladogram]
			}
			start()
		})

		let origin = {
			x: canvas.width/2,
			y: canvas.height/2,
		}

		const Input = {
			polar_coord: { mag: Infinity, angle: 0 },
			cart_coord: { x: 0, y: 0 },
			mouse_clicking: false,
		}


		let path = [0]

		let next_root_node = null

		let start_animation_radius = {
			going: false,
			time: 0,
			start: undefined,
			duration: 500,
			back: false
		}

		function hash_name(string) {
			return Math.abs(string.split('').reduce((acc, char) => acc ^ ((acc<<5)-acc) + char.charCodeAt(0), 0)) % 36 * 10
		}

		function polar_to_cart(mag, angle) {
			return [
				Math.cos(angle) * mag + origin.x,
				Math.sin(angle) * mag + origin.y
			]
		}

		function ease(x) {
			return 1 - (1 - x) * (1 - x)
		}

		function goto_node(node, new_path) {
			next_root_node = node
			path = new_path
			start_animation_radius.going = true
			start_animation_radius.time = 0
			start_animation_radius.back = true
		}

		function node_hash(node) {
			if (node.hash) return node.hash
			node.hash = hash_name(node.name)
			return node.hash
		}

		function generate_colors(root, odd = false) {
			const hash = Math.floor(hash_name(root.name)/4)
			root.hash = odd ? hash : hash + 180

			for (let i = 0; i < root.children.length; ++i) {
				generate_colors(root.children[i], i % 2 != 0)
			}
		}

		function draw_section(arc_start, arc_size, inner_radius, outer_radius) {
			const start_angle = arc_start - (Math.PI/2)
			const end_angle = start_angle + arc_size
			ctx.beginPath()
			ctx.arc(origin.x, origin.y, inner_radius, end_angle, start_angle, true )
			ctx.arc(origin.x, origin.y, outer_radius, start_angle, end_angle, false)
			ctx.fill()
		}

		function draw_node_children(root, iradius, arc_size, arc_start, depth, parents_index, options) {
			const {init_depth, size, anim_radius} = options

			if (depth == 0) return null
			if (iradius > anim_radius) return null
			if (root.children.length == 0) return null


			const count = root.children.length
			const ARC = arc_size/count
			const opacity = depth/init_depth

			let texts = []

			let node_to_return = null

			for (let index = 0; index < count; ++index) {
				const node = root.children[index]
				
				const arc_s = index*ARC+arc_start
				const hover =
					!start_animation_radius.going &&
					Input.polar_coord.mag > iradius && 
					Input.polar_coord.mag < iradius + size &&
					Input.polar_coord.angle > arc_s &&
					Input.polar_coord.angle < arc_s + ARC

				if (hover) {
					console.log([...parents_index, index])
					node_to_return = { path: [...parents_index, index], node }
				}
				
				const oradius = Math.max(iradius + 5, Math.min(iradius + size + (hover ? 3 : 0), anim_radius))
				
				ctx.fillStyle = `hsla(${node_hash(node)}, 50%, 60%, ${(hover ? 1 : opacity)*100}%)`

				draw_section(arc_s, ARC, iradius + 5 - (hover ? 3 : 0), oradius)

				if (hover || depth == 1 || node.children.length == 0) {
					const coord = polar_to_cart(oradius+10, arc_s+ARC/2 - Math.PI/2)
					texts.push({
						coord: coord,
						align: coord[0] < origin.x ? 'end' : 'start',
						name: node.name
					})
				}

				let new_hover = draw_node_children(node, iradius+size, ARC, arc_s, depth - 1, [...parents_index, index], options)
				if (node_to_return === null) node_to_return = new_hover
			}

			ctx.font = `${8+24*opacity}px Arial`
			ctx.fillStyle = `rgb(224, 224, 224)`

			for (const {coord, name, align} of texts) {
				ctx.textAlign = align
				ctx.fillText(name, ...coord)
			}

			return node_to_return
		}

		function show_idle(timestamp) {
			const root = root_node

			ctx.clearRect(0, 0, canvas.width, canvas.height)

			if (start_animation_radius.going) {
				if (start_animation_radius.start == undefined)
					start_animation_radius.start = timestamp

				start_animation_radius.time = timestamp - start_animation_radius.start

				if (start_animation_radius.time >= start_animation_radius.duration) {
					start_animation_radius.going = false
					start_animation_radius.time = start_animation_radius.duration
					start_animation_radius.start = undefined
				}
			}

			const anim_radius = start_animation_radius.back 
				? (1 - ease(start_animation_radius.time/start_animation_radius.duration)) * 255
				: ease(start_animation_radius.time/start_animation_radius.duration) * 255

			ctx.font = `24px Arial`
			ctx.textAlign = 'start'
			let path_y = 0
			let last_node = path_helper
			for (const index of path.slice(0, -1)) {
				const node = last_node.children[index]

				const hover =
					Input.cart_coord.y > 10 + path_y*24 &&
					Input.cart_coord.y < 34 + path_y*24 &&
					Input.cart_coord.x < 20 + ctx.measureText(node.name).width

				if (hover && Input.mouse_clicking) {
					console.log(path.slice(0, path_y+1))
					goto_node(node, path.slice(0, path_y+1))
				}

				ctx.fillStyle = `hsl(${node_hash(node)}, 50%, 60%)`
				ctx.fillText(node.name, hover ? 30 : 20, 20 + path_y*24)
				path_y += 1
				last_node = node
			}

			ctx.fillStyle = `hsl(${node_hash(root)}, 50%, 60%)`
			ctx.beginPath()
			ctx.arc(origin.x, origin.y, Math.min(100, anim_radius), 0, TAU)
			ctx.fill()

			const text_size = root.name.length <= 12 ? 24 : Math.floor(240/root.name.length)
			ctx.font = `${(anim_radius/200)*text_size}px Arial`
			ctx.textAlign = 'center'
			ctx.fillStyle = `#e0e0e0`
			ctx.fillText(root.name, origin.x, origin.y)

			if (100 <= anim_radius) {
				let hovering = draw_node_children(root, 100, TAU, 0, 3, path, {
					init_depth: 3,
					size: 50,
					anim_radius: anim_radius
				})

				if (hovering !== null && Input.mouse_clicking) {
					Input.mouse_clicking = false
					goto_node(hovering.node, hovering.path)
				}
			}

			if (next_root_node && start_animation_radius.going == false) {
				root_node = next_root_node
				next_root_node = null
				start_animation_radius.going = true
				start_animation_radius.time = 0
				start_animation_radius.back = false
			}

			window.requestAnimationFrame(show_idle)
		}

		function start() {
			generate_colors(root_node)

			start_animation_radius.going = true
			window.requestAnimationFrame(show_idle)
		}

		document.addEventListener('mousemove', (e) => {
			const dist = Math.hypot(e.clientX - origin.x, e.clientY - origin.y)
			const angle = Math.atan2(e.clientY - origin.y, e.clientX - origin.x)
			const norm = (angle > 0 ? angle : angle + 2 * Math.PI) - 3*Math.PI/2

			Input.polar_coord.mag = dist
			Input.polar_coord.angle = (norm > 0 ? norm : norm + 4*Math.PI/2)

			Input.cart_coord.x = e.clientX
			Input.cart_coord.y = e.clientY
		})

		document.addEventListener('mousedown', (e) => { 
			if (e.button == 0) Input.mouse_clicking = true
			else if (e.button == 2 && path.length > 1) {
				let new_path = path.slice(0, -1)
				let last_node = path_helper
				for (const index of new_path) {
					last_node = last_node.children[index]
				}
				goto_node(last_node, new_path)
			}
		})
		document.addEventListener('mouseup', (e) => { 
			if (e.button == 0) Input.mouse_clicking = false
		})

		window.addEventListener('resize', () => {
			canvas.width = window.innerWidth
			canvas.height = window.innerHeight
			origin.x = canvas.width/2
			origin.y = canvas.height/2
		});
	</script>
</body>
</html>